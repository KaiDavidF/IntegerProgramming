import math
from sympy import Matrix

def lattice_intersection(P_gen, Q_gen):
    """
    Given two lattices L1 and L2 in Z^d, each specified by a list of generators,
    compute a generating set for the intersection L1 ∩ L2.
    
    Each lattice is given by a list of generators (each generator is a list of ints).
    
    Returns:
      A list of generators (each a list of ints) for L1 ∩ L2.
      (If the only common vector is 0, returns [[0, 0, ..., 0]].)
    """
    # Check that both generator lists are nonempty.
    if not P_gen:
        raise ValueError("First lattice generator list is empty; expected at least one generator.")
    if not Q_gen:
        raise ValueError("Second lattice generator list is empty; expected at least one generator.")

    # Ambient dimension d is determined by the first generator.
    d = len(P_gen[0])
    
    # Create matrix P whose columns are the generators of L1.
    P = Matrix.hstack(*[Matrix(gen) for gen in P_gen])
    # Create matrix Q whose columns are the generators of L2.
    Q = Matrix.hstack(*[Matrix(gen) for gen in Q_gen])
    
    # Check that all generators lie in Z^d.
    if P.rows != d or Q.rows != d:
        raise ValueError("All generators must have the same dimension.")

    k = P.cols  # number of generators for L1
    l = Q.cols  # number of generators for L2

    # Form the block matrix M = [P | -Q].
    M = P.row_join(-Q)
    
    # Compute a basis for the nullspace of M over Q.
    ns = M.nullspace()
    if not ns:
        # The nullspace is trivial, so L1 ∩ L2 = {0}.
        return [[0] * d]
    
    generators = []
    for v in ns:
        # v is a column vector in Q^(k+l). We wish to clear denominators to get an integer vector.
        # v is a Matrix with one column.
        denominators = [term.as_numer_denom()[1] for term in v]
        lcm_d = 1
        for d_val in denominators:
            lcm_d = (lcm_d * d_val) // math.gcd(lcm_d, d_val)
        # Multiply v by lcm_d to obtain an integer vector.
        v_int = lcm_d * v
        
        # Extract the first k entries of v_int, corresponding to the coefficients for P.
        a = v_int[:k, :]
        # Compute x = P * a, which is in L1 ∩ L2.
        x = P * a
        # Flatten x into a list of ints.
        x_list = [int(x[i]) for i in range(x.rows)]
        generators.append(x_list)
    
    return generators

# --- Example usage ---
if __name__ == "__main__":
    # Example: In Z^3,
    # Let L1 be generated by p1 = [1, 0, 0] and p2 = [0, 1, 0].
    # Let L2 be generated by q1 = [1, 0, 1] and q2 = [0, 1, 1].
    P_gen = [
        [1, 2, 3],
        [8, 4, 5],
        [2, 0, 0]
    ]
    Q_gen = [
        [5, 2, 3],
        [1, 1, 100],
        [5, 2, 3]
    ]
    
    inter_gen = lattice_intersection(P_gen, Q_gen)
    print("Generators for the intersection lattice:")
    for vec in inter_gen:
        print(vec)
