from sympy import Matrix
from sympy.matrices.normalforms import smith_normal_form as _snf
from sympy.polys.domains.integerring import ZZ

def lattice_intersection(P_gen, Q_gen):
    """
    Given two lattices L1 and L2 in Z^d, each specified by a list of generators,
    compute a generating set for the intersection L1 ∩ L2.

    Parameters:
      P_gen: list of generators for L1. Each generator is a list of integers of length d.
      Q_gen: list of generators for L2. Each generator is a list of integers of length d.

    Returns:
      A list of generators (each a list of ints) for the lattice L1 ∩ L2.
      (If the only common vector is 0, returns [[0, 0, ..., 0]].)
    """
    # Check that both lists are nonempty.
    if not P_gen:
        raise ValueError("First lattice generator list is empty; expected at least one generator.")
    if not Q_gen:
        raise ValueError("Second lattice generator list is empty; expected at least one generator.")

    # Determine the ambient dimension d.
    d = len(P_gen[0])
    # Form the matrix P (d x k) with generators as columns.
    P = Matrix.hstack(*[Matrix(gen) for gen in P_gen])
    # Similarly for Q (d x l)
    Q = Matrix.hstack(*[Matrix(gen) for gen in Q_gen])
    
    # Check that the generators live in the same ambient space.
    if P.rows != d or Q.rows != d:
        raise ValueError("All generators must have the same dimension.")
    
    k = P.cols  # number of generators for L1
    l = Q.cols  # number of generators for L2

    # Form the d x (k+l) matrix: M = [P | -Q]
    M = P.row_join(-Q)

    # Compute the Smith Normal Form with transformation matrices.
    # We pass calculate_transformation=True and domain=ZZ.
    # _snf returns a triple (D, U, V) such that U * M * V = D.
    D, U, V = _snf(M, domain=ZZ)
    # Convert the results to standard sympy Matrix objects:
    D = D.to_Matrix()
    U = U.to_Matrix()
    V = V.to_Matrix()

    # The number of nonzero diagonal entries in D is the rank r of M.
    r = sum(1 for i in range(min(D.rows, D.cols)) if D[i, i] != 0)
    n = k + l  # total number of columns in M

    # If r equals n, the only solution is trivial (only the zero vector).
    if r == n:
        return [[0] * d]
    
    # The kernel of M (over Z) is given by the last (n - r) columns of V.
    kernel_basis = V[:, r:n]  # This is an (n x (n-r)) matrix

    # For each kernel vector v, split it into two parts:
    #  - a (the first k entries) corresponds to coefficients for P.
    #  - b (the last l entries) corresponds to coefficients for Q.
    # Then x = P * a is a vector in L1 ∩ L2.
    generators = []
    for j in range(kernel_basis.cols):
        v = kernel_basis[:, j]
        a = v[:k, :]  # first k entries (as a column vector)
        x = P * a     # compute x = P * a in Z^d
        # Flatten x into a list of ints.
        x_list = [int(val) for val in x]
        generators.append(x_list)
    
    return generators

# --- Example usage ---
if __name__ == "__main__":
    # Example lattices in Z^3:
    # Lattice L1 is generated by p1 = [1, 0, 0] and p2 = [0, 1, 0]
    # Lattice L2 is generated by q1 = [1, 0, 1] and q2 = [0, 1, 1]
    P_gen = [
        [1, 0, 0],
        [0, 1, 0]
    ]
    Q_gen = [
        [1, 0, 1],
        [0, 1, 1]
    ]
    
    inter_gen = lattice_intersection(P_gen, Q_gen)
    print("Generators for the intersection lattice:")
    for vec in inter_gen:
        print(vec)
