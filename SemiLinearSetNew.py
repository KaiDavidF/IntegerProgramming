import numpy as np
from minimalPoints import getMinimalPoints
from LinearEquation import solveIntegerEquation


def constructNaturalNumbers(dimension : int):
    return np.zeros(dimension, dtype=int), np.eye(dimension, dtype=int)



class LinearSet:
    def __init__(self, b : list[int], P : list[list[int]]):
        self.b = b
        self.P = P
        self.dimension = len(b)
    
    def __str__(self):
        return f"b = {self.b}, P = {self.P}"
    
    def removeRedundantPeriods(self):
        new_P = []
        # Check each generator in P
        for i, p in enumerate(self.P):
            # Remove the zero vector if present.
            if all(x == 0 for x in p):
                continue
            
            # Build a list of all other generators
            other_generators = [q for j, q in enumerate(self.P) if j != i]
            
            # If there are no other generators, we keep p.
            if not other_generators:
                new_P.append(p)
                continue
            
            # Check if p can be generated by the others.
            # That is, does there exist a nonnegative integer solution z (for the generators in other_generators)
            # such that: other_generators * z = p ?
            solution = solveIntegerEquation(other_generators, p)
            if solution is None:
                # No solution exists, so p is not redundant.
                new_P.append(p)
            else:
                # p is redundant, so we do not add it.
                pass
        
        # Update the period set with the nonredundant generators.
        self.P = new_P
        
    
    def contains(self, x):
        if len(x) != self.dimension:
            return False
        
        # If there are no generators, then L(b,P) is just the singleton {b}.
        if not self.P:
            return x == self.b
        
        # Compute the right-hand side for each coordinate:
        rhs = [x[j] - self.b[j] for j in range(self.dimension)]
    
        A = self.P
        
        solution = solveIntegerEquation(A, rhs)
        return solution is not None
    
    # Receives multiple vectors and computes Minkowski sum of vectors in that order.
    def addVectors(self, vectors : list[list[int]]):
        for v in vectors:
            assert len(v) == self.dimension
        bNat, PNat = constructNaturalNumbers(self.dimension)
        
        P = self.P
        b = self.b
        for v in vectors:
            P = P + [v]
            C, Q = intersect(bNat, PNat, b, P)
            # etc etc
        
        pass
    
    def addVector(self, v : list[int]):
        """
        Computes the Minkowski sum: L(b, P) + ℕ₀·v.
        """
        assert len(v) == self.dimension
        bNat, PNat = constructNaturalNumbers(self.dimension)
        
        P = self.P + [v] # add the possibly negative vector to period set.
        b = self.b
        
        C, Q = intersect(b, P, bNat, PNat)
        
        numOfCoeff = self.dimension
        return [point[:numOfCoeff] for point in C], [point[:numOfCoeff] for point in Q]
        
class SemiLinearSet:
    def __init__(self, linearSets : list[LinearSet]):
        self.linearSets = linearSets
        
    def removeRedundantPeriods(self):
        for L in self.linearSets:
            L.removeRedundantPeriods()
    
    def addVector(self, v):
        linearSets = []
        basePoints = []
        for lSet in self.linearSets:
            B, P = lSet.addVector(v)
            # TODO: Optimierungsidee: Vielleicht enthält eines der neuen Linear Sets bereits das aktuelle Linear Set?
            P = [list(x) for x in set(tuple(x) for x in P)]
            for b in B:
                if b not in basePoints:
                    linearSets.append(LinearSet(b, P))
                    basePoints.append(b)
        self.linearSets = linearSets
        
        # TODO: Vielleicht können wir das hier anders lösen, zB über Redundant constraint elimination
        self.removeRedundantBasePoints()
        self.removeRedundantPeriods()
        
    def contains(self, x):
        for lSet in self.linearSets:
            if lSet.contains(x):
                return True
        return False
    
    def __str__(self):
        semiLinearString = ""
        for lSet in self.linearSets:
            semiLinearString += str(lSet) + '\n'
        return semiLinearString
    
    def getAllBasePoints(self):
        return [L.b for L in self.linearSets]
    def getSomePeriod(self):
        return self.linearSets[0].P
    
    # Assumes that P is the same for every base point.
    def removeRedundantBasePoints(self):
        B = self.getAllBasePoints()
        P = self.getSomePeriod()
        newB = removeRedundantBasePoints(B, P)
        self.linearSets = []
        for b in newB:
            self.linearSets.append(LinearSet(b, P))

            

def intersect(b1 : list[int], P1 : list[list[int]], b2 : list[int], P2 : list[list[int]]):
    b1 = np.array(b1, dtype=int)
    P1 = np.array(P1, dtype=int)
    b2 = np.array(b2, dtype=int)
    P2 = np.array(P2, dtype=int)
    
    # TODO: Change order here.
    A = np.concatenate((P2.T, -P1.T), axis=1)
    b = b1 - b2
    
    C = getMinimalPoints(A=A, b=b, noZero=False)
    P = getMinimalPoints(A=A, b=np.zeros_like(b), noZero=True)
    
    return C, P
    
def testContains():
    L = LinearSet(b = [0,3], P = [[0,1]])
    for i in range(10):
        assert L.contains([0,3+i])
    assert not L.contains([0,2])
    assert not L.contains([1,1])
    
def removeRedundantBasePoints(B, P):
    reduced_B = B.copy()
    changed = True
    while changed:
        changed = False
        # Iterate over a copy of the current base points.
        for b in reduced_B.copy():
            # Check if b is contained in the semilinear set defined by the other base points.
            is_redundant = False
            for b_other in reduced_B:
                if b_other == b:
                    continue
                # Create a linear set with base point b_other and period set P.
                ls = LinearSet(b_other, P)
                # If b is contained in ls, then b is redundant.
                if ls.contains(b):
                    is_redundant = True
                    break
            if is_redundant:
                reduced_B.remove(b)
                # Indicate that a change occurred so that we restart the checking process.
                changed = True
                # Break out of the for-loop to restart the scan on the updated list.
                break
    return reduced_B

def test1():
    L = SemiLinearSet([LinearSet(b = [0,3], P = [[0,1]])])
    L.addVector([3,-1])
    print(L)
    L.addVector([5,-1])
    print(L)
    
def test2():
    L = SemiLinearSet([LinearSet(b = [5,0,0], P = [[1,0,0]])])
    L.addVector([-1,23,5])
    L.addVector([1,0,0])
    L.addVector([2,-1,3])

    print(L)
        
if __name__ == "__main__":
    #test1()
    test1()
    

    
    
  
    